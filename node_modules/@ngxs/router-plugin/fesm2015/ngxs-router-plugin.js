import { __decorate, __metadata } from 'tslib';
import { NgZone, Injectable, NgModule } from '@angular/core';
import { NavigationCancel, NavigationError, Router, RoutesRecognized, ResolveEnd } from '@angular/router';
import { Action, Selector, State, Store, NgxsModule } from '@ngxs/store';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 * @template T
 */
class RouterStateSerializer {
}
class DefaultRouterStateSerializer {
    /**
     * @param {?} routerState
     * @return {?}
     */
    serialize(routerState) {
        return {
            root: this.serializeRoute(routerState.root),
            url: routerState.url
        };
    }
    /**
     * @private
     * @param {?} route
     * @return {?}
     */
    serializeRoute(route) {
        /** @type {?} */
        const children = route.children.map((/**
         * @param {?} c
         * @return {?}
         */
        c => this.serializeRoute(c)));
        return {
            url: route.url,
            params: route.params,
            queryParams: route.queryParams,
            fragment: route.fragment,
            data: route.data,
            outlet: route.outlet,
            component: null,
            routeConfig: null,
            root: (/** @type {?} */ (null)),
            parent: null,
            firstChild: children[0],
            children: children,
            pathFromRoot: (/** @type {?} */ (null)),
            paramMap: route.paramMap,
            queryParamMap: route.queryParamMap,
            toString: route.toString
        };
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Public event api of the router
 */
class Navigate {
    /**
     * @param {?} path
     * @param {?=} queryParams
     * @param {?=} extras
     */
    constructor(path, queryParams, extras) {
        this.path = path;
        this.queryParams = queryParams;
        this.extras = extras;
    }
    /**
     * @return {?}
     */
    static get type() {
        // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138
        return '[Router] Navigate';
    }
}
/**
 *
 * Angular Routers internal state events
 *
 */
/**
 * An action dispatched when the router navigates.
 * @template T
 */
class RouterNavigation {
    /**
     * @param {?} routerState
     * @param {?} event
     */
    constructor(routerState, event) {
        this.routerState = routerState;
        this.event = event;
    }
    /**
     * @return {?}
     */
    static get type() {
        // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138
        return '[Router] RouterNavigation';
    }
}
/**
 * An action dispatched when the router cancel navigation.
 * @template T, V
 */
class RouterCancel {
    /**
     * @param {?} routerState
     * @param {?} storeState
     * @param {?} event
     */
    constructor(routerState, storeState, event) {
        this.routerState = routerState;
        this.storeState = storeState;
        this.event = event;
    }
    /**
     * @return {?}
     */
    static get type() {
        // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138
        return '[Router] RouterCancel';
    }
}
/**
 * An action dispatched when the router errors.
 * @template T, V
 */
class RouterError {
    /**
     * @param {?} routerState
     * @param {?} storeState
     * @param {?} event
     */
    constructor(routerState, storeState, event) {
        this.routerState = routerState;
        this.storeState = storeState;
        this.event = event;
    }
    /**
     * @return {?}
     */
    static get type() {
        // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138
        return '[Router] RouterError';
    }
}

var RouterState_1;
let RouterState = RouterState_1 = class RouterState {
    /**
     * @param {?} _store
     * @param {?} _router
     * @param {?} _serializer
     * @param {?} _ngZone
     */
    constructor(_store, _router, _serializer, _ngZone) {
        this._store = _store;
        this._router = _router;
        this._serializer = _serializer;
        this._ngZone = _ngZone;
        this.dispatchTriggeredByRouter = false; // used only in dev mode in combination with routerReducer
        // used only in dev mode in combination with routerReducer
        this.navigationTriggeredByDispatch = false; // used only in dev mode in combination with routerReducer
        this.setUpStoreListener();
        this.setUpStateRollbackEvents();
    }
    // used only in dev mode in combination with routerReducer
    /**
     * Selectors
     * @template T
     * @param {?} state
     * @return {?}
     */
    static state(state) {
        return state && state.state;
    }
    /**
     * @param {?} state
     * @return {?}
     */
    static url(state) {
        return state && state.state && state.state.url;
    }
    /**
     * @param {?} ctx
     * @param {?} action
     * @return {?}
     */
    navigate(ctx, action) {
        this._ngZone.run((/**
         * @return {?}
         */
        () => this._router.navigate(action.path, Object.assign({ queryParams: action.queryParams }, action.extras))));
    }
    /**
     * @param {?} ctx
     * @param {?} action
     * @return {?}
     */
    angularRouterAction(ctx, action) {
        ctx.setState(Object.assign({}, ctx.getState(), { state: action.routerState, navigationId: action.event.id }));
    }
    /**
     * @private
     * @return {?}
     */
    setUpStoreListener() {
        this._store.select(RouterState_1).subscribe((/**
         * @param {?} s
         * @return {?}
         */
        s => {
            this.routerState = s;
        }));
        this._store.select(RouterState_1.state).subscribe((/**
         * @return {?}
         */
        () => {
            this.navigateIfNeeded();
        }));
    }
    /**
     * @private
     * @return {?}
     */
    setUpStateRollbackEvents() {
        this._router.events.subscribe((/**
         * @param {?} e
         * @return {?}
         */
        e => {
            if (e instanceof RoutesRecognized) {
                this.lastRoutesRecognized = e;
            }
            else if (e instanceof ResolveEnd) {
                this.resolveEnd(e.state);
            }
            else if (e instanceof NavigationCancel) {
                this.dispatchRouterCancel(e);
            }
            else if (e instanceof NavigationError) {
                this.dispatchRouterError(e);
            }
        }));
    }
    /**
     * The `ResolveEnd` event is always triggered after running all resolvers
     * that are linked to some route and child routes
     * @private
     * @param {?} routerStateSnapshot
     * @return {?}
     */
    resolveEnd(routerStateSnapshot) {
        this.routerStateSnapshot = this._serializer.serialize(routerStateSnapshot);
        if (this.shouldDispatchRouterNavigation()) {
            this.dispatchRouterNavigation();
        }
    }
    /**
     * @private
     * @return {?}
     */
    shouldDispatchRouterNavigation() {
        if (!this.routerState)
            return true;
        return !this.navigationTriggeredByDispatch;
    }
    /**
     * @private
     * @return {?}
     */
    navigateIfNeeded() {
        if (!this.routerState || !this.routerState.state) {
            return;
        }
        if (this.dispatchTriggeredByRouter)
            return;
        if (this._router.url !== this.routerState.state.url) {
            this.navigationTriggeredByDispatch = true;
            this._ngZone.run((/**
             * @return {?}
             */
            () => this._router.navigateByUrl((/** @type {?} */ (this.routerState.state)).url)));
        }
    }
    /**
     * @private
     * @return {?}
     */
    dispatchRouterNavigation() {
        this.dispatchRouterAction(new RouterNavigation(this.routerStateSnapshot, new RoutesRecognized(this.lastRoutesRecognized.id, this.lastRoutesRecognized.url, this.lastRoutesRecognized.urlAfterRedirects, this.routerStateSnapshot)));
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    dispatchRouterCancel(event) {
        this.dispatchRouterAction(new RouterCancel(this.routerStateSnapshot, this.routerState, event));
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    dispatchRouterError(event) {
        this.dispatchRouterAction(new RouterError(this.routerStateSnapshot, this.routerState, new NavigationError(event.id, event.url, `${event}`)));
    }
    /**
     * @private
     * @template T
     * @param {?} action
     * @return {?}
     */
    dispatchRouterAction(action) {
        this.dispatchTriggeredByRouter = true;
        try {
            this._store.dispatch(action);
        }
        finally {
            this.dispatchTriggeredByRouter = false;
            this.navigationTriggeredByDispatch = false;
        }
    }
};
RouterState.decorators = [
    { type: Injectable }
];
/** @nocollapse */
RouterState.ctorParameters = () => [
    { type: Store },
    { type: Router },
    { type: RouterStateSerializer },
    { type: NgZone }
];
__decorate([
    Action(Navigate),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Navigate]),
    __metadata("design:returntype", void 0)
], RouterState.prototype, "navigate", null);
__decorate([
    Action([RouterNavigation, RouterError, RouterCancel]),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object]),
    __metadata("design:returntype", void 0)
], RouterState.prototype, "angularRouterAction", null);
__decorate([
    Selector(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], RouterState, "state", null);
__decorate([
    Selector(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Object)
], RouterState, "url", null);
RouterState = RouterState_1 = __decorate([
    State({
        name: 'router',
        defaults: {
            state: undefined,
            navigationId: undefined
        }
    }),
    __metadata("design:paramtypes", [Store,
        Router,
        RouterStateSerializer,
        NgZone])
], RouterState);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @dynamic
class NgxsRouterPluginModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: NgxsRouterPluginModule
        };
    }
}
NgxsRouterPluginModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    // NOTE: Must mark as `dynamic` due to
                    // https://github.com/dherges/ng-packagr/issues/767
                    NgxsModule.forFeature([RouterState])
                ],
                providers: [{ provide: RouterStateSerializer, useClass: DefaultRouterStateSerializer }]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NgxsRouterPluginModule, RouterState, RouterStateSerializer, DefaultRouterStateSerializer, Navigate, RouterNavigation, RouterCancel, RouterError };

//# sourceMappingURL=ngxs-router-plugin.js.map