/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { META_KEY, META_OPTIONS_KEY, SELECTOR_META_KEY } from '../symbols';
/**
 * @record
 * @template T
 */
export function ObjectKeyMap() { }
/**
 * @record
 * @template T, U
 */
export function StateClass() { }
if (false) {
    /* Skipping unnamed member:
    [META_KEY]?: MetaDataModel;*/
    /* Skipping unnamed member:
    [META_OPTIONS_KEY]?: StoreOptions<U>;*/
    /* Skipping unhandled member: new (...args: any[]): T;*/
}
/**
 * @record
 * @template T
 */
export function StateOperations() { }
if (false) {
    /**
     * @return {?}
     */
    StateOperations.prototype.getState = function () { };
    /**
     * @param {?} val
     * @return {?}
     */
    StateOperations.prototype.setState = function (val) { };
    /**
     * @param {?} actions
     * @return {?}
     */
    StateOperations.prototype.dispatch = function (actions) { };
}
/**
 * @record
 */
export function MetaDataModel() { }
if (false) {
    /** @type {?} */
    MetaDataModel.prototype.name;
    /** @type {?} */
    MetaDataModel.prototype.actions;
    /** @type {?} */
    MetaDataModel.prototype.defaults;
    /** @type {?} */
    MetaDataModel.prototype.path;
    /** @type {?} */
    MetaDataModel.prototype.selectFromAppState;
    /** @type {?|undefined} */
    MetaDataModel.prototype.children;
    /** @type {?} */
    MetaDataModel.prototype.instance;
}
/**
 * @record
 */
export function SelectorMetaDataModel() { }
if (false) {
    /** @type {?} */
    SelectorMetaDataModel.prototype.selectFromAppState;
    /** @type {?} */
    SelectorMetaDataModel.prototype.originalFn;
    /** @type {?} */
    SelectorMetaDataModel.prototype.containerClass;
    /** @type {?} */
    SelectorMetaDataModel.prototype.selectorName;
}
/**
 * @record
 */
export function MappedStore() { }
if (false) {
    /** @type {?} */
    MappedStore.prototype.name;
    /** @type {?} */
    MappedStore.prototype.actions;
    /** @type {?} */
    MappedStore.prototype.defaults;
    /** @type {?} */
    MappedStore.prototype.instance;
    /** @type {?} */
    MappedStore.prototype.depth;
}
/**
 * @record
 */
export function StatesAndDefaults() { }
if (false) {
    /** @type {?} */
    StatesAndDefaults.prototype.defaults;
    /** @type {?} */
    StatesAndDefaults.prototype.states;
}
/**
 * Ensures metadata is attached to the class and returns it.
 *
 * @ignore
 * @param {?} target
 * @return {?}
 */
export function ensureStoreMetadata(target) {
    if (!target.hasOwnProperty(META_KEY)) {
        /** @type {?} */
        var defaultMetadata = {
            name: null,
            actions: {},
            defaults: {},
            path: null,
            selectFromAppState: null,
            children: [],
            instance: null
        };
        Object.defineProperty(target, META_KEY, { value: defaultMetadata });
    }
    return getStoreMetadata(target);
}
/**
 * Get the metadata attached to the state class if it exists.
 *
 * @ignore
 * @param {?} target
 * @return {?}
 */
export function getStoreMetadata(target) {
    return (/** @type {?} */ (target[META_KEY]));
}
/**
 * Ensures metadata is attached to the selector and returns it.
 *
 * @ignore
 * @param {?} target
 * @return {?}
 */
export function ensureSelectorMetadata(target) {
    if (!target.hasOwnProperty(SELECTOR_META_KEY)) {
        /** @type {?} */
        var defaultMetadata = {
            selectFromAppState: null,
            originalFn: null,
            containerClass: null,
            selectorName: null
        };
        Object.defineProperty(target, SELECTOR_META_KEY, { value: defaultMetadata });
    }
    return getSelectorMetadata(target);
}
/**
 * Get the metadata attached to the selector if it exists.
 *
 * @ignore
 * @param {?} target
 * @return {?}
 */
export function getSelectorMetadata(target) {
    return target[SELECTOR_META_KEY];
}
/**
 * Get a deeply nested value. Example:
 *
 *    getValue({ foo: bar: [] }, 'foo.bar') //=> []
 *
 * Note: This is not as fast as the `fastPropGetter` but is strict Content Security Policy compliant.
 * See perf hit: https://jsperf.com/fast-value-getter-given-path/1
 *
 * @ignore
 * @param {?} paths
 * @return {?}
 */
function compliantPropGetter(paths) {
    /** @type {?} */
    var copyOfPaths = tslib_1.__spread(paths);
    return (/**
     * @param {?} obj
     * @return {?}
     */
    function (obj) { return copyOfPaths.reduce((/**
     * @param {?} acc
     * @param {?} part
     * @return {?}
     */
    function (acc, part) { return acc && acc[part]; }), obj); });
}
/**
 * The generated function is faster than:
 * - pluck (Observable operator)
 * - memoize
 *
 * @ignore
 * @param {?} paths
 * @return {?}
 */
function fastPropGetter(paths) {
    /** @type {?} */
    var segments = paths;
    /** @type {?} */
    var seg = 'store.' + segments[0];
    /** @type {?} */
    var i = 0;
    /** @type {?} */
    var l = segments.length;
    /** @type {?} */
    var expr = seg;
    while (++i < l) {
        expr = expr + ' && ' + (seg = seg + '.' + segments[i]);
    }
    /** @type {?} */
    var fn = new Function('store', 'return ' + expr + ';');
    return (/** @type {?} */ (fn));
}
/**
 * Get a deeply nested value. Example:
 *
 *    getValue({ foo: bar: [] }, 'foo.bar') //=> []
 *
 * @ignore
 * @param {?} paths
 * @param {?} config
 * @return {?}
 */
export function propGetter(paths, config) {
    if (config && config.compatibility && config.compatibility.strictContentSecurityPolicy) {
        return compliantPropGetter(paths);
    }
    else {
        return fastPropGetter(paths);
    }
}
/**
 * Given an array of states, it will return a object graph. Example:
 *    const states = [
 *      Cart,
 *      CartSaved,
 *      CartSavedItems
 *    ]
 *
 * would return:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 * @ignore
 * @param {?} stateClasses
 * @return {?}
 */
export function buildGraph(stateClasses) {
    /** @type {?} */
    var findName = (/**
     * @param {?} stateClass
     * @return {?}
     */
    function (stateClass) {
        /** @type {?} */
        var meta = stateClasses.find((/**
         * @param {?} g
         * @return {?}
         */
        function (g) { return g === stateClass; }));
        if (!meta) {
            throw new Error("Child state not found: " + stateClass + ". \r\nYou may have forgotten to add states to module");
        }
        return (/** @type {?} */ ((/** @type {?} */ (meta[META_KEY])).name));
    });
    return stateClasses.reduce((/**
     * @param {?} result
     * @param {?} stateClass
     * @return {?}
     */
    function (result, stateClass) {
        var _a = (/** @type {?} */ (stateClass[META_KEY])), name = _a.name, children = _a.children;
        result[(/** @type {?} */ (name))] = (children || []).map(findName);
        return result;
    }), {});
}
/**
 * Given a states array, returns object graph
 * returning the name and state metadata. Example:
 *
 *  const graph = {
 *    cart: { metadata }
 *  };
 *
 * @ignore
 * @param {?} states
 * @return {?}
 */
export function nameToState(states) {
    return states.reduce((/**
     * @param {?} result
     * @param {?} stateClass
     * @return {?}
     */
    function (result, stateClass) {
        /** @type {?} */
        var meta = (/** @type {?} */ (stateClass[META_KEY]));
        result[(/** @type {?} */ (meta.name))] = stateClass;
        return result;
    }), {});
}
/**
 * Given a object relationship graph will return the full path
 * for the child items. Example:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 * would return:
 *
 *  const r = {
 *    cart: 'cart',
 *    saved: 'cart.saved',
 *    items: 'cart.saved.items'
 *  };
 *
 * @ignore
 * @param {?} obj
 * @param {?=} newObj
 * @return {?}
 */
export function findFullParentPath(obj, newObj) {
    if (newObj === void 0) { newObj = {}; }
    /** @type {?} */
    var visit = (/**
     * @param {?} child
     * @param {?} keyToFind
     * @return {?}
     */
    function (child, keyToFind) {
        for (var key in child) {
            if (child.hasOwnProperty(key) && child[key].indexOf(keyToFind) >= 0) {
                /** @type {?} */
                var parent_1 = visit(child, key);
                return parent_1 !== null ? parent_1 + "." + key : key;
            }
        }
        return null;
    });
    for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
            /** @type {?} */
            var parent_2 = visit(obj, key);
            newObj[key] = parent_2 ? parent_2 + "." + key : key;
        }
    }
    return newObj;
}
/**
 * Given a object graph, it will return the items topologically sorted Example:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 * would return:
 *
 *  const results = [
 *    'items',
 *    'saved',
 *    'cart'
 *  ];
 *
 * @ignore
 * @param {?} graph
 * @return {?}
 */
export function topologicalSort(graph) {
    /** @type {?} */
    var sorted = [];
    /** @type {?} */
    var visited = {};
    /** @type {?} */
    var visit = (/**
     * @param {?} name
     * @param {?=} ancestors
     * @return {?}
     */
    function (name, ancestors) {
        if (ancestors === void 0) { ancestors = []; }
        if (!Array.isArray(ancestors)) {
            ancestors = [];
        }
        ancestors.push(name);
        visited[name] = true;
        graph[name].forEach((/**
         * @param {?} dep
         * @return {?}
         */
        function (dep) {
            if (ancestors.indexOf(dep) >= 0) {
                throw new Error("Circular dependency '" + dep + "' is required by '" + name + "': " + ancestors.join(' -> '));
            }
            if (visited[dep]) {
                return;
            }
            visit(dep, ancestors.slice(0));
        }));
        if (sorted.indexOf(name) < 0) {
            sorted.push(name);
        }
    });
    Object.keys(graph).forEach((/**
     * @param {?} k
     * @return {?}
     */
    function (k) { return visit(k); }));
    return sorted.reverse();
}
/**
 * Returns if the parameter is a object or not.
 *
 * @ignore
 * @param {?} obj
 * @return {?}
 */
export function isObject(obj) {
    return (typeof obj === 'object' && obj !== null) || typeof obj === 'function';
}
/** @type {?} */
var DOLLAR_CHAR_CODE = 36;
/**
 * If `foo$` => make it just `foo`
 *
 * @ignore
 * @param {?} name
 * @return {?}
 */
export function removeDollarAtTheEnd(name) {
    /** @type {?} */
    var lastCharIndex = name.length - 1;
    /** @type {?} */
    var dollarAtTheEnd = name.charCodeAt(lastCharIndex) === DOLLAR_CHAR_CODE;
    return dollarAtTheEnd ? name.slice(0, lastCharIndex) : name;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW50ZXJuYWxzLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQG5neHMvc3RvcmUvIiwic291cmNlcyI6WyJzcmMvaW50ZXJuYWwvaW50ZXJuYWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBRUEsT0FBTyxFQUNMLFFBQVEsRUFDUixnQkFBZ0IsRUFFaEIsaUJBQWlCLEVBRWxCLE1BQU0sWUFBWSxDQUFDOzs7OztBQUdwQixrQ0FFQzs7Ozs7QUFHRCxnQ0FLQzs7Ozs7Ozs7Ozs7O0FBS0QscUNBTUM7Ozs7O0lBTEMscURBQWM7Ozs7O0lBRWQsd0RBQW9COzs7OztJQUVwQiw0REFBaUQ7Ozs7O0FBR25ELG1DQVFDOzs7SUFQQyw2QkFBb0I7O0lBQ3BCLGdDQUErQzs7SUFDL0MsaUNBQWM7O0lBQ2QsNkJBQW9COztJQUNwQiwyQ0FBMkM7O0lBQzNDLGlDQUF3Qjs7SUFDeEIsaUNBQWM7Ozs7O0FBS2hCLDJDQUtDOzs7SUFKQyxtREFBMkM7O0lBQzNDLDJDQUE0Qjs7SUFDNUIsK0NBQW9COztJQUNwQiw2Q0FBNEI7Ozs7O0FBRzlCLGlDQU1DOzs7SUFMQywyQkFBYTs7SUFDYiw4QkFBK0M7O0lBQy9DLCtCQUFjOztJQUNkLCtCQUFjOztJQUNkLDRCQUFjOzs7OztBQUdoQix1Q0FHQzs7O0lBRkMscUNBQWM7O0lBQ2QsbUNBQXNCOzs7Ozs7Ozs7QUFReEIsTUFBTSxVQUFVLG1CQUFtQixDQUFDLE1BQWtCO0lBQ3BELElBQUksQ0FBQyxNQUFNLENBQUMsY0FBYyxDQUFDLFFBQVEsQ0FBQyxFQUFFOztZQUM5QixlQUFlLEdBQWtCO1lBQ3JDLElBQUksRUFBRSxJQUFJO1lBQ1YsT0FBTyxFQUFFLEVBQUU7WUFDWCxRQUFRLEVBQUUsRUFBRTtZQUNaLElBQUksRUFBRSxJQUFJO1lBQ1Ysa0JBQWtCLEVBQUUsSUFBSTtZQUN4QixRQUFRLEVBQUUsRUFBRTtZQUNaLFFBQVEsRUFBRSxJQUFJO1NBQ2Y7UUFFRCxNQUFNLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFB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cG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcclxuXHJcbmltcG9ydCB7XHJcbiAgTUVUQV9LRVksXHJcbiAgTUVUQV9PUFRJT05TX0tFWSxcclxuICBOZ3hzQ29uZmlnLFxyXG4gIFNFTEVDVE9SX01FVEFfS0VZLFxyXG4gIFN0b3JlT3B0aW9uc1xyXG59IGZyb20gJy4uL3N5bWJvbHMnO1xyXG5pbXBvcnQgeyBBY3Rpb25IYW5kbGVyTWV0YURhdGEgfSBmcm9tICcuLi9hY3Rpb25zL3N5bWJvbHMnO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBPYmplY3RLZXlNYXA8VD4ge1xyXG4gIFtrZXk6IHN0cmluZ106IFQ7XHJcbn1cclxuXHJcbi8vIGluc3BpcmVkIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQzNjc0Mzg5XHJcbmV4cG9ydCBpbnRlcmZhY2UgU3RhdGVDbGFzczxUID0gYW55LCBVID0gYW55PiB7XHJcbiAgW01FVEFfS0VZXT86IE1ldGFEYXRhTW9kZWw7XHJcbiAgW01FVEFfT1BUSU9OU19LRVldPzogU3RvcmVPcHRpb25zPFU+O1xyXG5cclxuICBuZXcgKC4uLmFyZ3M6IGFueVtdKTogVDtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgU3RhdGVLZXlHcmFwaCA9IE9iamVjdEtleU1hcDxzdHJpbmdbXT47XHJcbmV4cG9ydCB0eXBlIFN0YXRlc0J5TmFtZSA9IE9iamVjdEtleU1hcDxTdGF0ZUNsYXNzPjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgU3RhdGVPcGVyYXRpb25zPFQ+IHtcclxuICBnZXRTdGF0ZSgpOiBUO1xyXG5cclxuICBzZXRTdGF0ZSh2YWw6IFQpOiBUO1xyXG5cclxuICBkaXNwYXRjaChhY3Rpb25zOiBhbnkgfCBhbnlbXSk6IE9ic2VydmFibGU8dm9pZD47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgTWV0YURhdGFNb2RlbCB7XHJcbiAgbmFtZTogc3RyaW5nIHwgbnVsbDtcclxuICBhY3Rpb25zOiBPYmplY3RLZXlNYXA8QWN0aW9uSGFuZGxlck1ldGFEYXRhW10+O1xyXG4gIGRlZmF1bHRzOiBhbnk7XHJcbiAgcGF0aDogc3RyaW5nIHwgbnVsbDtcclxuICBzZWxlY3RGcm9tQXBwU3RhdGU6IFNlbGVjdEZyb21TdGF0ZSB8IG51bGw7XHJcbiAgY2hpbGRyZW4/OiBTdGF0ZUNsYXNzW107XHJcbiAgaW5zdGFuY2U6IGFueTtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgU2VsZWN0RnJvbVN0YXRlID0gKHN0YXRlOiBhbnkpID0+IGFueTtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgU2VsZWN0b3JNZXRhRGF0YU1vZGVsIHtcclxuICBzZWxlY3RGcm9tQXBwU3RhdGU6IFNlbGVjdEZyb21TdGF0ZSB8IG51bGw7XHJcbiAgb3JpZ2luYWxGbjogRnVuY3Rpb24gfCBudWxsO1xyXG4gIGNvbnRhaW5lckNsYXNzOiBhbnk7XHJcbiAgc2VsZWN0b3JOYW1lOiBzdHJpbmcgfCBudWxsO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIE1hcHBlZFN0b3JlIHtcclxuICBuYW1lOiBzdHJpbmc7XHJcbiAgYWN0aW9uczogT2JqZWN0S2V5TWFwPEFjdGlvbkhhbmRsZXJNZXRhRGF0YVtdPjtcclxuICBkZWZhdWx0czogYW55O1xyXG4gIGluc3RhbmNlOiBhbnk7XHJcbiAgZGVwdGg6IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTdGF0ZXNBbmREZWZhdWx0cyB7XHJcbiAgZGVmYXVsdHM6IGFueTtcclxuICBzdGF0ZXM6IE1hcHBlZFN0b3JlW107XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFbnN1cmVzIG1ldGFkYXRhIGlzIGF0dGFjaGVkIHRvIHRoZSBjbGFzcyBhbmQgcmV0dXJucyBpdC5cclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZVN0b3JlTWV0YWRhdGEodGFyZ2V0OiBTdGF0ZUNsYXNzKTogTWV0YURhdGFNb2RlbCB7XHJcbiAgaWYgKCF0YXJnZXQuaGFzT3duUHJvcGVydHkoTUVUQV9LRVkpKSB7XHJcbiAgICBjb25zdCBkZWZhdWx0TWV0YWRhdGE6IE1ldGFEYXRhTW9kZWwgPSB7XHJcbiAgICAgIG5hbWU6IG51bGwsXHJcbiAgICAgIGFjdGlvbnM6IHt9LFxyXG4gICAgICBkZWZhdWx0czoge30sXHJcbiAgICAgIHBhdGg6IG51bGwsXHJcbiAgICAgIHNlbGVjdEZyb21BcHBTdGF0ZTogbnVsbCxcclxuICAgICAgY2hpbGRyZW46IFtdLFxyXG4gICAgICBpbnN0YW5jZTogbnVsbFxyXG4gICAgfTtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBNRVRBX0tFWSwgeyB2YWx1ZTogZGVmYXVsdE1ldGFkYXRhIH0pO1xyXG4gIH1cclxuICByZXR1cm4gZ2V0U3RvcmVNZXRhZGF0YSh0YXJnZXQpO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IHRoZSBtZXRhZGF0YSBhdHRhY2hlZCB0byB0aGUgc3RhdGUgY2xhc3MgaWYgaXQgZXhpc3RzLlxyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RvcmVNZXRhZGF0YSh0YXJnZXQ6IFN0YXRlQ2xhc3MpOiBNZXRhRGF0YU1vZGVsIHtcclxuICByZXR1cm4gdGFyZ2V0W01FVEFfS0VZXSE7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFbnN1cmVzIG1ldGFkYXRhIGlzIGF0dGFjaGVkIHRvIHRoZSBzZWxlY3RvciBhbmQgcmV0dXJucyBpdC5cclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZVNlbGVjdG9yTWV0YWRhdGEodGFyZ2V0OiBGdW5jdGlvbik6IFNlbGVjdG9yTWV0YURhdGFNb2RlbCB7XHJcbiAgaWYgKCF0YXJnZXQuaGFzT3duUHJvcGVydHkoU0VMRUNUT1JfTUVUQV9LRVkpKSB7XHJcbiAgICBjb25zdCBkZWZhdWx0TWV0YWRhdGE6IFNlbGVjdG9yTWV0YURhdGFNb2RlbCA9IHtcclxuICAgICAgc2VsZWN0RnJvbUFwcFN0YXRlOiBudWxsLFxyXG4gICAgICBvcmlnaW5hbEZuOiBudWxsLFxyXG4gICAgICBjb250YWluZXJDbGFzczogbnVsbCxcclxuICAgICAgc2VsZWN0b3JOYW1lOiBudWxsXHJcbiAgICB9O1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIFNFTEVDVE9SX01FVEFfS0VZLCB7IHZhbHVlOiBkZWZhdWx0TWV0YWRhdGEgfSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZ2V0U2VsZWN0b3JNZXRhZGF0YSh0YXJnZXQpO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IHRoZSBtZXRhZGF0YSBhdHRhY2hlZCB0byB0aGUgc2VsZWN0b3IgaWYgaXQgZXhpc3RzLlxyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2VsZWN0b3JNZXRhZGF0YSh0YXJnZXQ6IGFueSk6IFNlbGVjdG9yTWV0YURhdGFNb2RlbCB7XHJcbiAgcmV0dXJuIHRhcmdldFtTRUxFQ1RPUl9NRVRBX0tFWV07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgYSBkZWVwbHkgbmVzdGVkIHZhbHVlLiBFeGFtcGxlOlxyXG4gKlxyXG4gKiAgICBnZXRWYWx1ZSh7IGZvbzogYmFyOiBbXSB9LCAnZm9vLmJhcicpIC8vPT4gW11cclxuICpcclxuICogTm90ZTogVGhpcyBpcyBub3QgYXMgZmFzdCBhcyB0aGUgYGZhc3RQcm9wR2V0dGVyYCBidXQgaXMgc3RyaWN0IENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IGNvbXBsaWFudC5cclxuICogU2VlIHBlcmYgaGl0OiBodHRwczovL2pzcGVyZi5jb20vZmFzdC12YWx1ZS1nZXR0ZXItZ2l2ZW4tcGF0aC8xXHJcbiAqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmZ1bmN0aW9uIGNvbXBsaWFudFByb3BHZXR0ZXIocGF0aHM6IHN0cmluZ1tdKTogKHg6IGFueSkgPT4gYW55IHtcclxuICBjb25zdCBjb3B5T2ZQYXRocyA9IFsuLi5wYXRoc107XHJcbiAgcmV0dXJuIG9iaiA9PiBjb3B5T2ZQYXRocy5yZWR1Y2UoKGFjYzogYW55LCBwYXJ0OiBzdHJpbmcpID0+IGFjYyAmJiBhY2NbcGFydF0sIG9iaik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgZ2VuZXJhdGVkIGZ1bmN0aW9uIGlzIGZhc3RlciB0aGFuOlxyXG4gKiAtIHBsdWNrIChPYnNlcnZhYmxlIG9wZXJhdG9yKVxyXG4gKiAtIG1lbW9pemVcclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZnVuY3Rpb24gZmFzdFByb3BHZXR0ZXIocGF0aHM6IHN0cmluZ1tdKTogKHg6IGFueSkgPT4gYW55IHtcclxuICBjb25zdCBzZWdtZW50cyA9IHBhdGhzO1xyXG4gIGxldCBzZWcgPSAnc3RvcmUuJyArIHNlZ21lbnRzWzBdO1xyXG4gIGxldCBpID0gMDtcclxuICBjb25zdCBsID0gc2VnbWVudHMubGVuZ3RoO1xyXG5cclxuICBsZXQgZXhwciA9IHNlZztcclxuICB3aGlsZSAoKytpIDwgbCkge1xyXG4gICAgZXhwciA9IGV4cHIgKyAnICYmICcgKyAoc2VnID0gc2VnICsgJy4nICsgc2VnbWVudHNbaV0pO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgZm4gPSBuZXcgRnVuY3Rpb24oJ3N0b3JlJywgJ3JldHVybiAnICsgZXhwciArICc7Jyk7XHJcblxyXG4gIHJldHVybiA8KHg6IGFueSkgPT4gYW55PmZuO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IGEgZGVlcGx5IG5lc3RlZCB2YWx1ZS4gRXhhbXBsZTpcclxuICpcclxuICogICAgZ2V0VmFsdWUoeyBmb286IGJhcjogW10gfSwgJ2Zvby5iYXInKSAvLz0+IFtdXHJcbiAqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBwcm9wR2V0dGVyKHBhdGhzOiBzdHJpbmdbXSwgY29uZmlnOiBOZ3hzQ29uZmlnKSB7XHJcbiAgaWYgKGNvbmZpZyAmJiBjb25maWcuY29tcGF0aWJpbGl0eSAmJiBjb25maWcuY29tcGF0aWJpbGl0eS5zdHJpY3RDb250ZW50U2VjdXJpdHlQb2xpY3kpIHtcclxuICAgIHJldHVybiBjb21wbGlhbnRQcm9wR2V0dGVyKHBhdGhzKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIGZhc3RQcm9wR2V0dGVyKHBhdGhzKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHaXZlbiBhbiBhcnJheSBvZiBzdGF0ZXMsIGl0IHdpbGwgcmV0dXJuIGEgb2JqZWN0IGdyYXBoLiBFeGFtcGxlOlxyXG4gKiAgICBjb25zdCBzdGF0ZXMgPSBbXHJcbiAqICAgICAgQ2FydCxcclxuICogICAgICBDYXJ0U2F2ZWQsXHJcbiAqICAgICAgQ2FydFNhdmVkSXRlbXNcclxuICogICAgXVxyXG4gKlxyXG4gKiB3b3VsZCByZXR1cm46XHJcbiAqXHJcbiAqICBjb25zdCBncmFwaCA9IHtcclxuICogICAgY2FydDogWydzYXZlZCddLFxyXG4gKiAgICBzYXZlZDogWydpdGVtcyddLFxyXG4gKiAgICBpdGVtczogW11cclxuICogIH07XHJcbiAqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBidWlsZEdyYXBoKHN0YXRlQ2xhc3NlczogU3RhdGVDbGFzc1tdKTogU3RhdGVLZXlHcmFwaCB7XHJcbiAgY29uc3QgZmluZE5hbWUgPSAoc3RhdGVDbGFzczogU3RhdGVDbGFzcykgPT4ge1xyXG4gICAgY29uc3QgbWV0YSA9IHN0YXRlQ2xhc3Nlcy5maW5kKGcgPT4gZyA9PT0gc3RhdGVDbGFzcyk7XHJcbiAgICBpZiAoIW1ldGEpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgIGBDaGlsZCBzdGF0ZSBub3QgZm91bmQ6ICR7c3RhdGVDbGFzc30uIFxcclxcbllvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gYWRkIHN0YXRlcyB0byBtb2R1bGVgXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG1ldGFbTUVUQV9LRVldIS5uYW1lITtcclxuICB9O1xyXG5cclxuICByZXR1cm4gc3RhdGVDbGFzc2VzLnJlZHVjZTxTdGF0ZUtleUdyYXBoPihcclxuICAgIChyZXN1bHQ6IFN0YXRlS2V5R3JhcGgsIHN0YXRlQ2xhc3M6IFN0YXRlQ2xhc3MpID0+IHtcclxuICAgICAgY29uc3QgeyBuYW1lLCBjaGlsZHJlbiB9ID0gc3RhdGVDbGFzc1tNRVRBX0tFWV0hO1xyXG4gICAgICByZXN1bHRbbmFtZSFdID0gKGNoaWxkcmVuIHx8IFtdKS5tYXAoZmluZE5hbWUpO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfSxcclxuICAgIHt9XHJcbiAgKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdpdmVuIGEgc3RhdGVzIGFycmF5LCByZXR1cm5zIG9iamVjdCBncmFwaFxyXG4gKiByZXR1cm5pbmcgdGhlIG5hbWUgYW5kIHN0YXRlIG1ldGFkYXRhLiBFeGFtcGxlOlxyXG4gKlxyXG4gKiAgY29uc3QgZ3JhcGggPSB7XHJcbiAqICAgIGNhcnQ6IHsgbWV0YWRhdGEgfVxyXG4gKiAgfTtcclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG5hbWVUb1N0YXRlKHN0YXRlczogU3RhdGVDbGFzc1tdKTogT2JqZWN0S2V5TWFwPFN0YXRlQ2xhc3M+IHtcclxuICByZXR1cm4gc3RhdGVzLnJlZHVjZTxPYmplY3RLZXlNYXA8U3RhdGVDbGFzcz4+KFxyXG4gICAgKHJlc3VsdDogT2JqZWN0S2V5TWFwPFN0YXRlQ2xhc3M+LCBzdGF0ZUNsYXNzOiBTdGF0ZUNsYXNzKSA9PiB7XHJcbiAgICAgIGNvbnN0IG1ldGEgPSBzdGF0ZUNsYXNzW01FVEFfS0VZXSE7XHJcbiAgICAgIHJlc3VsdFttZXRhLm5hbWUhXSA9IHN0YXRlQ2xhc3M7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9LFxyXG4gICAge31cclxuICApO1xyXG59XHJcblxyXG4vKipcclxuICogR2l2ZW4gYSBvYmplY3QgcmVsYXRpb25zaGlwIGdyYXBoIHdpbGwgcmV0dXJuIHRoZSBmdWxsIHBhdGhcclxuICogZm9yIHRoZSBjaGlsZCBpdGVtcy4gRXhhbXBsZTpcclxuICpcclxuICogIGNvbnN0IGdyYXBoID0ge1xyXG4gKiAgICBjYXJ0OiBbJ3NhdmVkJ10sXHJcbiAqICAgIHNhdmVkOiBbJ2l0ZW1zJ10sXHJcbiAqICAgIGl0ZW1zOiBbXVxyXG4gKiAgfTtcclxuICpcclxuICogd291bGQgcmV0dXJuOlxyXG4gKlxyXG4gKiAgY29uc3QgciA9IHtcclxuICogICAgY2FydDogJ2NhcnQnLFxyXG4gKiAgICBzYXZlZDogJ2NhcnQuc2F2ZWQnLFxyXG4gKiAgICBpdGVtczogJ2NhcnQuc2F2ZWQuaXRlbXMnXHJcbiAqICB9O1xyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZmluZEZ1bGxQYXJlbnRQYXRoKFxyXG4gIG9iajogU3RhdGVLZXlHcmFwaCxcclxuICBuZXdPYmo6IE9iamVjdEtleU1hcDxzdHJpbmc+ID0ge31cclxuKTogT2JqZWN0S2V5TWFwPHN0cmluZz4ge1xyXG4gIGNvbnN0IHZpc2l0ID0gKGNoaWxkOiBTdGF0ZUtleUdyYXBoLCBrZXlUb0ZpbmQ6IHN0cmluZyk6IHN0cmluZyB8IG51bGwgPT4ge1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gY2hpbGQpIHtcclxuICAgICAgaWYgKGNoaWxkLmhhc093blByb3BlcnR5KGtleSkgJiYgY2hpbGRba2V5XS5pbmRleE9mKGtleVRvRmluZCkgPj0gMCkge1xyXG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHZpc2l0KGNoaWxkLCBrZXkpO1xyXG4gICAgICAgIHJldHVybiBwYXJlbnQgIT09IG51bGwgPyBgJHtwYXJlbnR9LiR7a2V5fWAgOiBrZXk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH07XHJcblxyXG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xyXG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgIGNvbnN0IHBhcmVudCA9IHZpc2l0KG9iaiwga2V5KTtcclxuICAgICAgbmV3T2JqW2tleV0gPSBwYXJlbnQgPyBgJHtwYXJlbnR9LiR7a2V5fWAgOiBrZXk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbmV3T2JqO1xyXG59XHJcblxyXG4vKipcclxuICogR2l2ZW4gYSBvYmplY3QgZ3JhcGgsIGl0IHdpbGwgcmV0dXJuIHRoZSBpdGVtcyB0b3BvbG9naWNhbGx5IHNvcnRlZCBFeGFtcGxlOlxyXG4gKlxyXG4gKiAgY29uc3QgZ3JhcGggPSB7XHJcbiAqICAgIGNhcnQ6IFsnc2F2ZWQnXSxcclxuICogICAgc2F2ZWQ6IFsnaXRlbXMnXSxcclxuICogICAgaXRlbXM6IFtdXHJcbiAqICB9O1xyXG4gKlxyXG4gKiB3b3VsZCByZXR1cm46XHJcbiAqXHJcbiAqICBjb25zdCByZXN1bHRzID0gW1xyXG4gKiAgICAnaXRlbXMnLFxyXG4gKiAgICAnc2F2ZWQnLFxyXG4gKiAgICAnY2FydCdcclxuICogIF07XHJcbiAqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB0b3BvbG9naWNhbFNvcnQoZ3JhcGg6IFN0YXRlS2V5R3JhcGgpOiBzdHJpbmdbXSB7XHJcbiAgY29uc3Qgc29ydGVkOiBzdHJpbmdbXSA9IFtdO1xyXG4gIGNvbnN0IHZpc2l0ZWQ6IE9iamVjdEtleU1hcDxib29sZWFuPiA9IHt9O1xyXG5cclxuICBjb25zdCB2aXNpdCA9IChuYW1lOiBzdHJpbmcsIGFuY2VzdG9yczogc3RyaW5nW10gPSBbXSkgPT4ge1xyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFuY2VzdG9ycykpIHtcclxuICAgICAgYW5jZXN0b3JzID0gW107XHJcbiAgICB9XHJcblxyXG4gICAgYW5jZXN0b3JzLnB1c2gobmFtZSk7XHJcbiAgICB2aXNpdGVkW25hbWVdID0gdHJ1ZTtcclxuXHJcbiAgICBncmFwaFtuYW1lXS5mb3JFYWNoKChkZXA6IHN0cmluZykgPT4ge1xyXG4gICAgICBpZiAoYW5jZXN0b3JzLmluZGV4T2YoZGVwKSA+PSAwKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgYENpcmN1bGFyIGRlcGVuZGVuY3kgJyR7ZGVwfScgaXMgcmVxdWlyZWQgYnkgJyR7bmFtZX0nOiAke2FuY2VzdG9ycy5qb2luKCcgLT4gJyl9YFxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh2aXNpdGVkW2RlcF0pIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZpc2l0KGRlcCwgYW5jZXN0b3JzLnNsaWNlKDApKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGlmIChzb3J0ZWQuaW5kZXhPZihuYW1lKSA8IDApIHtcclxuICAgICAgc29ydGVkLnB1c2gobmFtZSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgT2JqZWN0LmtleXMoZ3JhcGgpLmZvckVhY2goayA9PiB2aXNpdChrKSk7XHJcblxyXG4gIHJldHVybiBzb3J0ZWQucmV2ZXJzZSgpO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyBpZiB0aGUgcGFyYW1ldGVyIGlzIGEgb2JqZWN0IG9yIG5vdC5cclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzT2JqZWN0KG9iajogYW55KSB7XHJcbiAgcmV0dXJuICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmogIT09IG51bGwpIHx8IHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbic7XHJcbn1cclxuXHJcbmNvbnN0IERPTExBUl9DSEFSX0NPREUgPSAzNjtcclxuXHJcbi8qKlxyXG4gKiBJZiBgZm9vJGAgPT4gbWFrZSBpdCBqdXN0IGBmb29gXHJcbiAqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVEb2xsYXJBdFRoZUVuZChuYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gIGNvbnN0IGxhc3RDaGFySW5kZXggPSBuYW1lLmxlbmd0aCAtIDE7XHJcbiAgY29uc3QgZG9sbGFyQXRUaGVFbmQgPSBuYW1lLmNoYXJDb2RlQXQobGFzdENoYXJJbmRleCkgPT09IERPTExBUl9DSEFSX0NPREU7XHJcbiAgcmV0dXJuIGRvbGxhckF0VGhlRW5kID8gbmFtZS5zbGljZSgwLCBsYXN0Q2hhckluZGV4KSA6IG5hbWU7XHJcbn1cclxuIl19