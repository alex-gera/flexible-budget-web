/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { META_KEY, META_OPTIONS_KEY, SELECTOR_META_KEY } from '../symbols';
/**
 * @record
 * @template T
 */
export function ObjectKeyMap() { }
/**
 * @record
 * @template T, U
 */
export function StateClass() { }
if (false) {
    /* Skipping unnamed member:
    [META_KEY]?: MetaDataModel;*/
    /* Skipping unnamed member:
    [META_OPTIONS_KEY]?: StoreOptions<U>;*/
    /* Skipping unhandled member: new (...args: any[]): T;*/
}
/**
 * @record
 * @template T
 */
export function StateOperations() { }
if (false) {
    /**
     * @return {?}
     */
    StateOperations.prototype.getState = function () { };
    /**
     * @param {?} val
     * @return {?}
     */
    StateOperations.prototype.setState = function (val) { };
    /**
     * @param {?} actions
     * @return {?}
     */
    StateOperations.prototype.dispatch = function (actions) { };
}
/**
 * @record
 */
export function MetaDataModel() { }
if (false) {
    /** @type {?} */
    MetaDataModel.prototype.name;
    /** @type {?} */
    MetaDataModel.prototype.actions;
    /** @type {?} */
    MetaDataModel.prototype.defaults;
    /** @type {?} */
    MetaDataModel.prototype.path;
    /** @type {?} */
    MetaDataModel.prototype.selectFromAppState;
    /** @type {?|undefined} */
    MetaDataModel.prototype.children;
    /** @type {?} */
    MetaDataModel.prototype.instance;
}
/**
 * @record
 */
export function SelectorMetaDataModel() { }
if (false) {
    /** @type {?} */
    SelectorMetaDataModel.prototype.selectFromAppState;
    /** @type {?} */
    SelectorMetaDataModel.prototype.originalFn;
    /** @type {?} */
    SelectorMetaDataModel.prototype.containerClass;
    /** @type {?} */
    SelectorMetaDataModel.prototype.selectorName;
}
/**
 * @record
 */
export function MappedStore() { }
if (false) {
    /** @type {?} */
    MappedStore.prototype.name;
    /** @type {?} */
    MappedStore.prototype.actions;
    /** @type {?} */
    MappedStore.prototype.defaults;
    /** @type {?} */
    MappedStore.prototype.instance;
    /** @type {?} */
    MappedStore.prototype.depth;
}
/**
 * @record
 */
export function StatesAndDefaults() { }
if (false) {
    /** @type {?} */
    StatesAndDefaults.prototype.defaults;
    /** @type {?} */
    StatesAndDefaults.prototype.states;
}
/**
 * Ensures metadata is attached to the class and returns it.
 *
 * @ignore
 * @param {?} target
 * @return {?}
 */
export function ensureStoreMetadata(target) {
    if (!target.hasOwnProperty(META_KEY)) {
        /** @type {?} */
        const defaultMetadata = {
            name: null,
            actions: {},
            defaults: {},
            path: null,
            selectFromAppState: null,
            children: [],
            instance: null
        };
        Object.defineProperty(target, META_KEY, { value: defaultMetadata });
    }
    return getStoreMetadata(target);
}
/**
 * Get the metadata attached to the state class if it exists.
 *
 * @ignore
 * @param {?} target
 * @return {?}
 */
export function getStoreMetadata(target) {
    return (/** @type {?} */ (target[META_KEY]));
}
/**
 * Ensures metadata is attached to the selector and returns it.
 *
 * @ignore
 * @param {?} target
 * @return {?}
 */
export function ensureSelectorMetadata(target) {
    if (!target.hasOwnProperty(SELECTOR_META_KEY)) {
        /** @type {?} */
        const defaultMetadata = {
            selectFromAppState: null,
            originalFn: null,
            containerClass: null,
            selectorName: null
        };
        Object.defineProperty(target, SELECTOR_META_KEY, { value: defaultMetadata });
    }
    return getSelectorMetadata(target);
}
/**
 * Get the metadata attached to the selector if it exists.
 *
 * @ignore
 * @param {?} target
 * @return {?}
 */
export function getSelectorMetadata(target) {
    return target[SELECTOR_META_KEY];
}
/**
 * Get a deeply nested value. Example:
 *
 *    getValue({ foo: bar: [] }, 'foo.bar') //=> []
 *
 * Note: This is not as fast as the `fastPropGetter` but is strict Content Security Policy compliant.
 * See perf hit: https://jsperf.com/fast-value-getter-given-path/1
 *
 * @ignore
 * @param {?} paths
 * @return {?}
 */
function compliantPropGetter(paths) {
    /** @type {?} */
    const copyOfPaths = [...paths];
    return (/**
     * @param {?} obj
     * @return {?}
     */
    obj => copyOfPaths.reduce((/**
     * @param {?} acc
     * @param {?} part
     * @return {?}
     */
    (acc, part) => acc && acc[part]), obj));
}
/**
 * The generated function is faster than:
 * - pluck (Observable operator)
 * - memoize
 *
 * @ignore
 * @param {?} paths
 * @return {?}
 */
function fastPropGetter(paths) {
    /** @type {?} */
    const segments = paths;
    /** @type {?} */
    let seg = 'store.' + segments[0];
    /** @type {?} */
    let i = 0;
    /** @type {?} */
    const l = segments.length;
    /** @type {?} */
    let expr = seg;
    while (++i < l) {
        expr = expr + ' && ' + (seg = seg + '.' + segments[i]);
    }
    /** @type {?} */
    const fn = new Function('store', 'return ' + expr + ';');
    return (/** @type {?} */ (fn));
}
/**
 * Get a deeply nested value. Example:
 *
 *    getValue({ foo: bar: [] }, 'foo.bar') //=> []
 *
 * @ignore
 * @param {?} paths
 * @param {?} config
 * @return {?}
 */
export function propGetter(paths, config) {
    if (config && config.compatibility && config.compatibility.strictContentSecurityPolicy) {
        return compliantPropGetter(paths);
    }
    else {
        return fastPropGetter(paths);
    }
}
/**
 * Given an array of states, it will return a object graph. Example:
 *    const states = [
 *      Cart,
 *      CartSaved,
 *      CartSavedItems
 *    ]
 *
 * would return:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 * @ignore
 * @param {?} stateClasses
 * @return {?}
 */
export function buildGraph(stateClasses) {
    /** @type {?} */
    const findName = (/**
     * @param {?} stateClass
     * @return {?}
     */
    (stateClass) => {
        /** @type {?} */
        const meta = stateClasses.find((/**
         * @param {?} g
         * @return {?}
         */
        g => g === stateClass));
        if (!meta) {
            throw new Error(`Child state not found: ${stateClass}. \r\nYou may have forgotten to add states to module`);
        }
        return (/** @type {?} */ ((/** @type {?} */ (meta[META_KEY])).name));
    });
    return stateClasses.reduce((/**
     * @param {?} result
     * @param {?} stateClass
     * @return {?}
     */
    (result, stateClass) => {
        const { name, children } = (/** @type {?} */ (stateClass[META_KEY]));
        result[(/** @type {?} */ (name))] = (children || []).map(findName);
        return result;
    }), {});
}
/**
 * Given a states array, returns object graph
 * returning the name and state metadata. Example:
 *
 *  const graph = {
 *    cart: { metadata }
 *  };
 *
 * @ignore
 * @param {?} states
 * @return {?}
 */
export function nameToState(states) {
    return states.reduce((/**
     * @param {?} result
     * @param {?} stateClass
     * @return {?}
     */
    (result, stateClass) => {
        /** @type {?} */
        const meta = (/** @type {?} */ (stateClass[META_KEY]));
        result[(/** @type {?} */ (meta.name))] = stateClass;
        return result;
    }), {});
}
/**
 * Given a object relationship graph will return the full path
 * for the child items. Example:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 * would return:
 *
 *  const r = {
 *    cart: 'cart',
 *    saved: 'cart.saved',
 *    items: 'cart.saved.items'
 *  };
 *
 * @ignore
 * @param {?} obj
 * @param {?=} newObj
 * @return {?}
 */
export function findFullParentPath(obj, newObj = {}) {
    /** @type {?} */
    const visit = (/**
     * @param {?} child
     * @param {?} keyToFind
     * @return {?}
     */
    (child, keyToFind) => {
        for (const key in child) {
            if (child.hasOwnProperty(key) && child[key].indexOf(keyToFind) >= 0) {
                /** @type {?} */
                const parent = visit(child, key);
                return parent !== null ? `${parent}.${key}` : key;
            }
        }
        return null;
    });
    for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
            /** @type {?} */
            const parent = visit(obj, key);
            newObj[key] = parent ? `${parent}.${key}` : key;
        }
    }
    return newObj;
}
/**
 * Given a object graph, it will return the items topologically sorted Example:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 * would return:
 *
 *  const results = [
 *    'items',
 *    'saved',
 *    'cart'
 *  ];
 *
 * @ignore
 * @param {?} graph
 * @return {?}
 */
export function topologicalSort(graph) {
    /** @type {?} */
    const sorted = [];
    /** @type {?} */
    const visited = {};
    /** @type {?} */
    const visit = (/**
     * @param {?} name
     * @param {?=} ancestors
     * @return {?}
     */
    (name, ancestors = []) => {
        if (!Array.isArray(ancestors)) {
            ancestors = [];
        }
        ancestors.push(name);
        visited[name] = true;
        graph[name].forEach((/**
         * @param {?} dep
         * @return {?}
         */
        (dep) => {
            if (ancestors.indexOf(dep) >= 0) {
                throw new Error(`Circular dependency '${dep}' is required by '${name}': ${ancestors.join(' -> ')}`);
            }
            if (visited[dep]) {
                return;
            }
            visit(dep, ancestors.slice(0));
        }));
        if (sorted.indexOf(name) < 0) {
            sorted.push(name);
        }
    });
    Object.keys(graph).forEach((/**
     * @param {?} k
     * @return {?}
     */
    k => visit(k)));
    return sorted.reverse();
}
/**
 * Returns if the parameter is a object or not.
 *
 * @ignore
 * @param {?} obj
 * @return {?}
 */
export function isObject(obj) {
    return (typeof obj === 'object' && obj !== null) || typeof obj === 'function';
}
/** @type {?} */
const DOLLAR_CHAR_CODE = 36;
/**
 * If `foo$` => make it just `foo`
 *
 * @ignore
 * @param {?} name
 * @return {?}
 */
export function removeDollarAtTheEnd(name) {
    /** @type {?} */
    const lastCharIndex = name.length - 1;
    /** @type {?} */
    const dollarAtTheEnd = name.charCodeAt(lastCharIndex) === DOLLAR_CHAR_CODE;
    return dollarAtTheEnd ? name.slice(0, lastCharIndex) : name;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW50ZXJuYWxzLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQG5neHMvc3RvcmUvIiwic291cmNlcyI6WyJzcmMvaW50ZXJuYWwvaW50ZXJuYWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFFQSxPQUFPLEVBQ0wsUUFBUSxFQUNSLGdCQUFnQixFQUVoQixpQkFBaUIsRUFFbEIsTUFBTSxZQUFZLENBQUM7Ozs7O0FBR3BCLGtDQUVDOzs7OztBQUdELGdDQUtDOzs7Ozs7Ozs7Ozs7QUFLRCxxQ0FNQzs7Ozs7SUFMQyxxREFBYzs7Ozs7SUFFZCx3REFBb0I7Ozs7O0lBRXBCLDREQUFpRDs7Ozs7QUFHbkQsbUNBUUM7OztJQVBDLDZCQUFvQjs7SUFDcEIsZ0NBQStDOztJQUMvQyxpQ0FBYzs7SUFDZCw2QkFBb0I7O0lBQ3BCLDJDQUEyQzs7SUFDM0MsaUNBQXdCOztJQUN4QixpQ0FBYzs7Ozs7QUFLaEIsMkNBS0M7OztJQUpDLG1EQUEyQzs7SUFDM0MsMkNBQTRCOztJQUM1QiwrQ0FBb0I7O0lBQ3BCLDZDQUE0Qjs7Ozs7QUFHOUIsaUNBTUM7OztJQUxDLDJCQUFhOztJQUNiLDhCQUErQzs7SUFDL0MsK0JBQWM7O0lBQ2QsK0JBQWM7O0lBQ2QsNEJBQWM7Ozs7O0FBR2hCLHVDQUdDOzs7SUFGQyxxQ0FBYzs7SUFDZCxtQ0FBc0I7Ozs7Ozs7OztBQVF4QixNQUFNLFVBQVUsbUJBQW1CLENBQUMsTUFBa0I7SUFDcEQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsUUFBUSxDQUFDLEVBQUU7O2NBQzlCLGVBQWUsR0FBa0I7WUFDckMsSUFBSSxFQUFFLElBQUk7WUFDVixPQUFPLEVBQUUsRUFBRTtZQUNYLFFBQVEsRUFBRSxFQUFFO1lBQ1osSUFBSSxFQUFFLElBQUk7WUFDVixrQkFBa0IsRUFBRSxJQUFJO1lBQ3hCLFFBQVEsRUFBRSxFQUFFO1lBQ1osUUFBUSxFQUFFLElBQUk7U0FDZjtRQUVELE1BQU0sQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFF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SUFBSSxDQUFDO0FBQzlELENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XHJcblxyXG5pbXBvcnQge1xyXG4gIE1FVEFfS0VZLFxyXG4gIE1FVEFfT1BUSU9OU19LRVksXHJcbiAgTmd4c0NvbmZpZyxcclxuICBTRUxFQ1RPUl9NRVRBX0tFWSxcclxuICBTdG9yZU9wdGlvbnNcclxufSBmcm9tICcuLi9zeW1ib2xzJztcclxuaW1wb3J0IHsgQWN0aW9uSGFuZGxlck1ldGFEYXRhIH0gZnJvbSAnLi4vYWN0aW9ucy9zeW1ib2xzJztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgT2JqZWN0S2V5TWFwPFQ+IHtcclxuICBba2V5OiBzdHJpbmddOiBUO1xyXG59XHJcblxyXG4vLyBpbnNwaXJlZCBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80MzY3NDM4OVxyXG5leHBvcnQgaW50ZXJmYWNlIFN0YXRlQ2xhc3M8VCA9IGFueSwgVSA9IGFueT4ge1xyXG4gIFtNRVRBX0tFWV0/OiBNZXRhRGF0YU1vZGVsO1xyXG4gIFtNRVRBX09QVElPTlNfS0VZXT86IFN0b3JlT3B0aW9uczxVPjtcclxuXHJcbiAgbmV3ICguLi5hcmdzOiBhbnlbXSk6IFQ7XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIFN0YXRlS2V5R3JhcGggPSBPYmplY3RLZXlNYXA8c3RyaW5nW10+O1xyXG5leHBvcnQgdHlwZSBTdGF0ZXNCeU5hbWUgPSBPYmplY3RLZXlNYXA8U3RhdGVDbGFzcz47XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFN0YXRlT3BlcmF0aW9uczxUPiB7XHJcbiAgZ2V0U3RhdGUoKTogVDtcclxuXHJcbiAgc2V0U3RhdGUodmFsOiBUKTogVDtcclxuXHJcbiAgZGlzcGF0Y2goYWN0aW9uczogYW55IHwgYW55W10pOiBPYnNlcnZhYmxlPHZvaWQ+O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIE1ldGFEYXRhTW9kZWwge1xyXG4gIG5hbWU6IHN0cmluZyB8IG51bGw7XHJcbiAgYWN0aW9uczogT2JqZWN0S2V5TWFwPEFjdGlvbkhhbmRsZXJNZXRhRGF0YVtdPjtcclxuICBkZWZhdWx0czogYW55O1xyXG4gIHBhdGg6IHN0cmluZyB8IG51bGw7XHJcbiAgc2VsZWN0RnJvbUFwcFN0YXRlOiBTZWxlY3RGcm9tU3RhdGUgfCBudWxsO1xyXG4gIGNoaWxkcmVuPzogU3RhdGVDbGFzc1tdO1xyXG4gIGluc3RhbmNlOiBhbnk7XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIFNlbGVjdEZyb21TdGF0ZSA9IChzdGF0ZTogYW55KSA9PiBhbnk7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFNlbGVjdG9yTWV0YURhdGFNb2RlbCB7XHJcbiAgc2VsZWN0RnJvbUFwcFN0YXRlOiBTZWxlY3RGcm9tU3RhdGUgfCBudWxsO1xyXG4gIG9yaWdpbmFsRm46IEZ1bmN0aW9uIHwgbnVsbDtcclxuICBjb250YWluZXJDbGFzczogYW55O1xyXG4gIHNlbGVjdG9yTmFtZTogc3RyaW5nIHwgbnVsbDtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBNYXBwZWRTdG9yZSB7XHJcbiAgbmFtZTogc3RyaW5nO1xyXG4gIGFjdGlvbnM6IE9iamVjdEtleU1hcDxBY3Rpb25IYW5kbGVyTWV0YURhdGFbXT47XHJcbiAgZGVmYXVsdHM6IGFueTtcclxuICBpbnN0YW5jZTogYW55O1xyXG4gIGRlcHRoOiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgU3RhdGVzQW5kRGVmYXVsdHMge1xyXG4gIGRlZmF1bHRzOiBhbnk7XHJcbiAgc3RhdGVzOiBNYXBwZWRTdG9yZVtdO1xyXG59XHJcblxyXG4vKipcclxuICogRW5zdXJlcyBtZXRhZGF0YSBpcyBhdHRhY2hlZCB0byB0aGUgY2xhc3MgYW5kIHJldHVybnMgaXQuXHJcbiAqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVTdG9yZU1ldGFkYXRhKHRhcmdldDogU3RhdGVDbGFzcyk6IE1ldGFEYXRhTW9kZWwge1xyXG4gIGlmICghdGFyZ2V0Lmhhc093blByb3BlcnR5KE1FVEFfS0VZKSkge1xyXG4gICAgY29uc3QgZGVmYXVsdE1ldGFkYXRhOiBNZXRhRGF0YU1vZGVsID0ge1xyXG4gICAgICBuYW1lOiBudWxsLFxyXG4gICAgICBhY3Rpb25zOiB7fSxcclxuICAgICAgZGVmYXVsdHM6IHt9LFxyXG4gICAgICBwYXRoOiBudWxsLFxyXG4gICAgICBzZWxlY3RGcm9tQXBwU3RhdGU6IG51bGwsXHJcbiAgICAgIGNoaWxkcmVuOiBbXSxcclxuICAgICAgaW5zdGFuY2U6IG51bGxcclxuICAgIH07XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgTUVUQV9LRVksIHsgdmFsdWU6IGRlZmF1bHRNZXRhZGF0YSB9KTtcclxuICB9XHJcbiAgcmV0dXJuIGdldFN0b3JlTWV0YWRhdGEodGFyZ2V0KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgbWV0YWRhdGEgYXR0YWNoZWQgdG8gdGhlIHN0YXRlIGNsYXNzIGlmIGl0IGV4aXN0cy5cclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFN0b3JlTWV0YWRhdGEodGFyZ2V0OiBTdGF0ZUNsYXNzKTogTWV0YURhdGFNb2RlbCB7XHJcbiAgcmV0dXJuIHRhcmdldFtNRVRBX0tFWV0hO1xyXG59XHJcblxyXG4vKipcclxuICogRW5zdXJlcyBtZXRhZGF0YSBpcyBhdHRhY2hlZCB0byB0aGUgc2VsZWN0b3IgYW5kIHJldHVybnMgaXQuXHJcbiAqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVTZWxlY3Rvck1ldGFkYXRhKHRhcmdldDogRnVuY3Rpb24pOiBTZWxlY3Rvck1ldGFEYXRhTW9kZWwge1xyXG4gIGlmICghdGFyZ2V0Lmhhc093blByb3BlcnR5KFNFTEVDVE9SX01FVEFfS0VZKSkge1xyXG4gICAgY29uc3QgZGVmYXVsdE1ldGFkYXRhOiBTZWxlY3Rvck1ldGFEYXRhTW9kZWwgPSB7XHJcbiAgICAgIHNlbGVjdEZyb21BcHBTdGF0ZTogbnVsbCxcclxuICAgICAgb3JpZ2luYWxGbjogbnVsbCxcclxuICAgICAgY29udGFpbmVyQ2xhc3M6IG51bGwsXHJcbiAgICAgIHNlbGVjdG9yTmFtZTogbnVsbFxyXG4gICAgfTtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBTRUxFQ1RPUl9NRVRBX0tFWSwgeyB2YWx1ZTogZGVmYXVsdE1ldGFkYXRhIH0pO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGdldFNlbGVjdG9yTWV0YWRhdGEodGFyZ2V0KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgbWV0YWRhdGEgYXR0YWNoZWQgdG8gdGhlIHNlbGVjdG9yIGlmIGl0IGV4aXN0cy5cclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFNlbGVjdG9yTWV0YWRhdGEodGFyZ2V0OiBhbnkpOiBTZWxlY3Rvck1ldGFEYXRhTW9kZWwge1xyXG4gIHJldHVybiB0YXJnZXRbU0VMRUNUT1JfTUVUQV9LRVldO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IGEgZGVlcGx5IG5lc3RlZCB2YWx1ZS4gRXhhbXBsZTpcclxuICpcclxuICogICAgZ2V0VmFsdWUoeyBmb286IGJhcjogW10gfSwgJ2Zvby5iYXInKSAvLz0+IFtdXHJcbiAqXHJcbiAqIE5vdGU6IFRoaXMgaXMgbm90IGFzIGZhc3QgYXMgdGhlIGBmYXN0UHJvcEdldHRlcmAgYnV0IGlzIHN0cmljdCBDb250ZW50IFNlY3VyaXR5IFBvbGljeSBjb21wbGlhbnQuXHJcbiAqIFNlZSBwZXJmIGhpdDogaHR0cHM6Ly9qc3BlcmYuY29tL2Zhc3QtdmFsdWUtZ2V0dGVyLWdpdmVuLXBhdGgvMVxyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5mdW5jdGlvbiBjb21wbGlhbnRQcm9wR2V0dGVyKHBhdGhzOiBzdHJpbmdbXSk6ICh4OiBhbnkpID0+IGFueSB7XHJcbiAgY29uc3QgY29weU9mUGF0aHMgPSBbLi4ucGF0aHNdO1xyXG4gIHJldHVybiBvYmogPT4gY29weU9mUGF0aHMucmVkdWNlKChhY2M6IGFueSwgcGFydDogc3RyaW5nKSA9PiBhY2MgJiYgYWNjW3BhcnRdLCBvYmopO1xyXG59XHJcblxyXG4vKipcclxuICogVGhlIGdlbmVyYXRlZCBmdW5jdGlvbiBpcyBmYXN0ZXIgdGhhbjpcclxuICogLSBwbHVjayAoT2JzZXJ2YWJsZSBvcGVyYXRvcilcclxuICogLSBtZW1vaXplXHJcbiAqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmZ1bmN0aW9uIGZhc3RQcm9wR2V0dGVyKHBhdGhzOiBzdHJpbmdbXSk6ICh4OiBhbnkpID0+IGFueSB7XHJcbiAgY29uc3Qgc2VnbWVudHMgPSBwYXRocztcclxuICBsZXQgc2VnID0gJ3N0b3JlLicgKyBzZWdtZW50c1swXTtcclxuICBsZXQgaSA9IDA7XHJcbiAgY29uc3QgbCA9IHNlZ21lbnRzLmxlbmd0aDtcclxuXHJcbiAgbGV0IGV4cHIgPSBzZWc7XHJcbiAgd2hpbGUgKCsraSA8IGwpIHtcclxuICAgIGV4cHIgPSBleHByICsgJyAmJiAnICsgKHNlZyA9IHNlZyArICcuJyArIHNlZ21lbnRzW2ldKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IGZuID0gbmV3IEZ1bmN0aW9uKCdzdG9yZScsICdyZXR1cm4gJyArIGV4cHIgKyAnOycpO1xyXG5cclxuICByZXR1cm4gPCh4OiBhbnkpID0+IGFueT5mbjtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBhIGRlZXBseSBuZXN0ZWQgdmFsdWUuIEV4YW1wbGU6XHJcbiAqXHJcbiAqICAgIGdldFZhbHVlKHsgZm9vOiBiYXI6IFtdIH0sICdmb28uYmFyJykgLy89PiBbXVxyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcHJvcEdldHRlcihwYXRoczogc3RyaW5nW10sIGNvbmZpZzogTmd4c0NvbmZpZykge1xyXG4gIGlmIChjb25maWcgJiYgY29uZmlnLmNvbXBhdGliaWxpdHkgJiYgY29uZmlnLmNvbXBhdGliaWxpdHkuc3RyaWN0Q29udGVudFNlY3VyaXR5UG9saWN5KSB7XHJcbiAgICByZXR1cm4gY29tcGxpYW50UHJvcEdldHRlcihwYXRocyk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBmYXN0UHJvcEdldHRlcihwYXRocyk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogR2l2ZW4gYW4gYXJyYXkgb2Ygc3RhdGVzLCBpdCB3aWxsIHJldHVybiBhIG9iamVjdCBncmFwaC4gRXhhbXBsZTpcclxuICogICAgY29uc3Qgc3RhdGVzID0gW1xyXG4gKiAgICAgIENhcnQsXHJcbiAqICAgICAgQ2FydFNhdmVkLFxyXG4gKiAgICAgIENhcnRTYXZlZEl0ZW1zXHJcbiAqICAgIF1cclxuICpcclxuICogd291bGQgcmV0dXJuOlxyXG4gKlxyXG4gKiAgY29uc3QgZ3JhcGggPSB7XHJcbiAqICAgIGNhcnQ6IFsnc2F2ZWQnXSxcclxuICogICAgc2F2ZWQ6IFsnaXRlbXMnXSxcclxuICogICAgaXRlbXM6IFtdXHJcbiAqICB9O1xyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRHcmFwaChzdGF0ZUNsYXNzZXM6IFN0YXRlQ2xhc3NbXSk6IFN0YXRlS2V5R3JhcGgge1xyXG4gIGNvbnN0IGZpbmROYW1lID0gKHN0YXRlQ2xhc3M6IFN0YXRlQ2xhc3MpID0+IHtcclxuICAgIGNvbnN0IG1ldGEgPSBzdGF0ZUNsYXNzZXMuZmluZChnID0+IGcgPT09IHN0YXRlQ2xhc3MpO1xyXG4gICAgaWYgKCFtZXRhKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICBgQ2hpbGQgc3RhdGUgbm90IGZvdW5kOiAke3N0YXRlQ2xhc3N9LiBcXHJcXG5Zb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIGFkZCBzdGF0ZXMgdG8gbW9kdWxlYFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBtZXRhW01FVEFfS0VZXSEubmFtZSE7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIHN0YXRlQ2xhc3Nlcy5yZWR1Y2U8U3RhdGVLZXlHcmFwaD4oXHJcbiAgICAocmVzdWx0OiBTdGF0ZUtleUdyYXBoLCBzdGF0ZUNsYXNzOiBTdGF0ZUNsYXNzKSA9PiB7XHJcbiAgICAgIGNvbnN0IHsgbmFtZSwgY2hpbGRyZW4gfSA9IHN0YXRlQ2xhc3NbTUVUQV9LRVldITtcclxuICAgICAgcmVzdWx0W25hbWUhXSA9IChjaGlsZHJlbiB8fCBbXSkubWFwKGZpbmROYW1lKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH0sXHJcbiAgICB7fVxyXG4gICk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHaXZlbiBhIHN0YXRlcyBhcnJheSwgcmV0dXJucyBvYmplY3QgZ3JhcGhcclxuICogcmV0dXJuaW5nIHRoZSBuYW1lIGFuZCBzdGF0ZSBtZXRhZGF0YS4gRXhhbXBsZTpcclxuICpcclxuICogIGNvbnN0IGdyYXBoID0ge1xyXG4gKiAgICBjYXJ0OiB7IG1ldGFkYXRhIH1cclxuICogIH07XHJcbiAqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBuYW1lVG9TdGF0ZShzdGF0ZXM6IFN0YXRlQ2xhc3NbXSk6IE9iamVjdEtleU1hcDxTdGF0ZUNsYXNzPiB7XHJcbiAgcmV0dXJuIHN0YXRlcy5yZWR1Y2U8T2JqZWN0S2V5TWFwPFN0YXRlQ2xhc3M+PihcclxuICAgIChyZXN1bHQ6IE9iamVjdEtleU1hcDxTdGF0ZUNsYXNzPiwgc3RhdGVDbGFzczogU3RhdGVDbGFzcykgPT4ge1xyXG4gICAgICBjb25zdCBtZXRhID0gc3RhdGVDbGFzc1tNRVRBX0tFWV0hO1xyXG4gICAgICByZXN1bHRbbWV0YS5uYW1lIV0gPSBzdGF0ZUNsYXNzO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfSxcclxuICAgIHt9XHJcbiAgKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdpdmVuIGEgb2JqZWN0IHJlbGF0aW9uc2hpcCBncmFwaCB3aWxsIHJldHVybiB0aGUgZnVsbCBwYXRoXHJcbiAqIGZvciB0aGUgY2hpbGQgaXRlbXMuIEV4YW1wbGU6XHJcbiAqXHJcbiAqICBjb25zdCBncmFwaCA9IHtcclxuICogICAgY2FydDogWydzYXZlZCddLFxyXG4gKiAgICBzYXZlZDogWydpdGVtcyddLFxyXG4gKiAgICBpdGVtczogW11cclxuICogIH07XHJcbiAqXHJcbiAqIHdvdWxkIHJldHVybjpcclxuICpcclxuICogIGNvbnN0IHIgPSB7XHJcbiAqICAgIGNhcnQ6ICdjYXJ0JyxcclxuICogICAgc2F2ZWQ6ICdjYXJ0LnNhdmVkJyxcclxuICogICAgaXRlbXM6ICdjYXJ0LnNhdmVkLml0ZW1zJ1xyXG4gKiAgfTtcclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRGdWxsUGFyZW50UGF0aChcclxuICBvYmo6IFN0YXRlS2V5R3JhcGgsXHJcbiAgbmV3T2JqOiBPYmplY3RLZXlNYXA8c3RyaW5nPiA9IHt9XHJcbik6IE9iamVjdEtleU1hcDxzdHJpbmc+IHtcclxuICBjb25zdCB2aXNpdCA9IChjaGlsZDogU3RhdGVLZXlHcmFwaCwga2V5VG9GaW5kOiBzdHJpbmcpOiBzdHJpbmcgfCBudWxsID0+IHtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIGNoaWxkKSB7XHJcbiAgICAgIGlmIChjaGlsZC5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIGNoaWxkW2tleV0uaW5kZXhPZihrZXlUb0ZpbmQpID49IDApIHtcclxuICAgICAgICBjb25zdCBwYXJlbnQgPSB2aXNpdChjaGlsZCwga2V5KTtcclxuICAgICAgICByZXR1cm4gcGFyZW50ICE9PSBudWxsID8gYCR7cGFyZW50fS4ke2tleX1gIDoga2V5O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9O1xyXG5cclxuICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcclxuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICBjb25zdCBwYXJlbnQgPSB2aXNpdChvYmosIGtleSk7XHJcbiAgICAgIG5ld09ialtrZXldID0gcGFyZW50ID8gYCR7cGFyZW50fS4ke2tleX1gIDoga2V5O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG5ld09iajtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdpdmVuIGEgb2JqZWN0IGdyYXBoLCBpdCB3aWxsIHJldHVybiB0aGUgaXRlbXMgdG9wb2xvZ2ljYWxseSBzb3J0ZWQgRXhhbXBsZTpcclxuICpcclxuICogIGNvbnN0IGdyYXBoID0ge1xyXG4gKiAgICBjYXJ0OiBbJ3NhdmVkJ10sXHJcbiAqICAgIHNhdmVkOiBbJ2l0ZW1zJ10sXHJcbiAqICAgIGl0ZW1zOiBbXVxyXG4gKiAgfTtcclxuICpcclxuICogd291bGQgcmV0dXJuOlxyXG4gKlxyXG4gKiAgY29uc3QgcmVzdWx0cyA9IFtcclxuICogICAgJ2l0ZW1zJyxcclxuICogICAgJ3NhdmVkJyxcclxuICogICAgJ2NhcnQnXHJcbiAqICBdO1xyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdG9wb2xvZ2ljYWxTb3J0KGdyYXBoOiBTdGF0ZUtleUdyYXBoKTogc3RyaW5nW10ge1xyXG4gIGNvbnN0IHNvcnRlZDogc3RyaW5nW10gPSBbXTtcclxuICBjb25zdCB2aXNpdGVkOiBPYmplY3RLZXlNYXA8Ym9vbGVhbj4gPSB7fTtcclxuXHJcbiAgY29uc3QgdmlzaXQgPSAobmFtZTogc3RyaW5nLCBhbmNlc3RvcnM6IHN0cmluZ1tdID0gW10pID0+IHtcclxuICAgIGlmICghQXJyYXkuaXNBcnJheShhbmNlc3RvcnMpKSB7XHJcbiAgICAgIGFuY2VzdG9ycyA9IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIGFuY2VzdG9ycy5wdXNoKG5hbWUpO1xyXG4gICAgdmlzaXRlZFtuYW1lXSA9IHRydWU7XHJcblxyXG4gICAgZ3JhcGhbbmFtZV0uZm9yRWFjaCgoZGVwOiBzdHJpbmcpID0+IHtcclxuICAgICAgaWYgKGFuY2VzdG9ycy5pbmRleE9mKGRlcCkgPj0gMCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAgIGBDaXJjdWxhciBkZXBlbmRlbmN5ICcke2RlcH0nIGlzIHJlcXVpcmVkIGJ5ICcke25hbWV9JzogJHthbmNlc3RvcnMuam9pbignIC0+ICcpfWBcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodmlzaXRlZFtkZXBdKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2aXNpdChkZXAsIGFuY2VzdG9ycy5zbGljZSgwKSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAoc29ydGVkLmluZGV4T2YobmFtZSkgPCAwKSB7XHJcbiAgICAgIHNvcnRlZC5wdXNoKG5hbWUpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIE9iamVjdC5rZXlzKGdyYXBoKS5mb3JFYWNoKGsgPT4gdmlzaXQoaykpO1xyXG5cclxuICByZXR1cm4gc29ydGVkLnJldmVyc2UoKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgaWYgdGhlIHBhcmFtZXRlciBpcyBhIG9iamVjdCBvciBub3QuXHJcbiAqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc09iamVjdChvYmo6IGFueSkge1xyXG4gIHJldHVybiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsKSB8fCB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nO1xyXG59XHJcblxyXG5jb25zdCBET0xMQVJfQ0hBUl9DT0RFID0gMzY7XHJcblxyXG4vKipcclxuICogSWYgYGZvbyRgID0+IG1ha2UgaXQganVzdCBgZm9vYFxyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlRG9sbGFyQXRUaGVFbmQobmFtZTogc3RyaW5nKTogc3RyaW5nIHtcclxuICBjb25zdCBsYXN0Q2hhckluZGV4ID0gbmFtZS5sZW5ndGggLSAxO1xyXG4gIGNvbnN0IGRvbGxhckF0VGhlRW5kID0gbmFtZS5jaGFyQ29kZUF0KGxhc3RDaGFySW5kZXgpID09PSBET0xMQVJfQ0hBUl9DT0RFO1xyXG4gIHJldHVybiBkb2xsYXJBdFRoZUVuZCA/IG5hbWUuc2xpY2UoMCwgbGFzdENoYXJJbmRleCkgOiBuYW1lO1xyXG59XHJcbiJdfQ==